# Храните деньги в… #blog

Попытаемся в это посте понять как лучше хранить деньги в базах данных и какой тип использовать для работы с ними в коде.

> А в чём вообще проблем? Что не так с числами с плавающей точкой?

Если кратко с ними все хорошо, но только они вообще не про деньги. Приведу несколько примеров, которые сбивают с толку:

```python
# Python 3.9.7 (default, Sep 10 2021, 14:59:43)
# [GCC 11.2.0] on linux
>>> 0.1+0.11
0.21000000000000002  # почему?
>>> 1.3+1.6
2.9000000000000004  # что за ...?
```

Если думаете, что проблема в языке Python, то ошибаетесь, вот код на Go

```go
// go version go1.18 linux/amd64
fmt.Printf("%.6f", float32(1.3+1.6))  // 2.9000000
fmt.Printf("%.9f", float32(1.3+1.6))  // 2.900000095
fmt.Printf("%.15f", float32(1.3+1.6)) // 2.900000095367432
fmt.Printf("%.25f", float32(1.3+1.6)) // 2.9000000953674316406250000

// ещё немного "магии"
fmt.Printf("%f", float32(16777217.0)) // 16777216.000000
```

И аналогичные примеры на Си:

```c
// gcc 11.2.0
float a;
a = 3.2;
printf("a=%.15f\n", a); // a=3.200000047683716
a = 0.1;
printf("a=%.9f\n", a);  // a=0.100000001
```

Очевидно, что с такими погрешностями в вычислениях нормально обрабатывать денежные транзакции не получится.

## Немного истории

Как это не странно, когда-то компьютеры ничего не знали о типе float. Вычисления были целочисленными или каждый производитель ЭВМ использовал свой подход.

В 1975 Intel начал разработку сопроцессора для вычислений с плавающей точкой для своих микропроцессоров i8086/8 и i432. Там была достаточная интересная история развитие идей и конкуренцию с DEC, подробнее можно прочитать [тут](https://web.archive.org/web/20160304114859/http://www.intel.com/content/dam/www/public/us/en/documents/case-studies/floating-point-case-study.pdf), но суть в том, что в 1980 уже вышел первый черновик стандарта, а в 1985 и его финальная версия **IEEE 754-1985**.

**IEEE 754** определяется промышленный стандарт представления чисел с плавающей точкой в компьютерах. За прошедшие годы выходила еще пара его версий [IEEE 754-2008](https://ieeexplore.ieee.org/document/4610935) и [IEEE 754-2019](https://ieeexplore.ieee.org/document/8766229).

Если очень кратно, то суть IEEE 754 в том, решить несколько проблем

- в каком формате хранить числа с плавающей точкой в компьютерах (двоичное представление таких чисел)
- какая должна быть у них точность
- как обеспечить скорость вычисления при работе с ними 
- как много памяти они должны занимать
- не должно быть неоднозначности в представлении таких чисел

Попробуйте подумать над этими вопросами и поймете, что это не так уж и просто. А точнее **невозможно отобразить бесконечное множество вещественных чисел на конечных набор байт**, с которыми работает компьютер. За все приходится платить и потеря точности это как раз та самая цена.

Главная идея IEEE 754 в представлении чисел в научной нотации. Вы наверное уже видели такие записи `1234.5=1.2345e3` или `0.0054321=5.4321e-3`? Это короткая запись выражений:

$$
1234.5 = 1.2345 \cdot 10^3
$$

$$
0.0054321 = 5.4321 \cdot 10^{-3}
$$

С числами с плавающей точкой все тоже самое, только за основу взята не десятичная система исчисления, а двоичная:

$$  
1234.5 \approx 1.2 \cdot 2^{10}
$$

$$
0.0054321 \approx 1.4 \cdot 2^{-8}
$$

Можно записать и более точно, тогда будет понятнее

$$
4 = 1 \cdot 2^{2}
$$

$$
16 = 1 \cdot 2^{4}
$$

$$
0.5 = 1 \cdot 2^{-1}
$$

$$
0.75 = 1.5 \cdot 2^{-1}
$$

$$
0.25 = 1 \cdot 2^{-2}
$$

$$
38.4 = 1.2 \cdot 2^5
$$

$$
0.0375 = 1.2 \cdot 2^{-5}
$$

Каждое число представляется в виде

$$
(-1)^{sign} \cdot (1 + fraction) \cdot 2^{(exponent - bias)}
$$

Тут несколько констант и 3 переменные, определяющие запись

1. <span style="color:#c5fcff">**sign**</span> - 1 бит под знак числа, чтобы понимать положительное оно или отрицательное. Удобно потом брать значение и использовать его в выражении `(-1)^sign` для определения знака.
2. <span style="color:#ffaead">**fraction**</span> - мантисса, вещественна часть числа от 0 до 1, в примере про `0.75 = 1.5 * 2^(-1)`, мантисса будет `0.5 = (1.5 - 1)`. Единицу отбрасывают для экономии памяти, так как оно все равно всегда есть в нормализованной записи, то зачем ее хранить, если можно помнить о том, что ее нужно всегда в конце добавить к результату.
3. <span style="color:#9fffad">**exponent**</span> - порядок, та самая степень двойки как в примерах выше, но со сдвигом на *bias*. Последний решает проблему знака, но не у самого числа, а у порядка. Например для числе с одинарной точностью, `bias=127`, тогда экспонента -2 будет хранится как 125, а +2 как 129. Это позволяет использовать всего 8 бит и диапазон значений от 1 до 254, чтобы работать с вариантам степеней двойки от -126 до +127.

Еще IEEE 754 оговаривает такие не обычные комбинации как плюс/минус бесконечности (Inf) и неопределенное число (NaN), например полученное в результате деления на ноль.

## Приведение к машинному виду

Теперь попробуем конвертировать числа с плавающей точной в машинный вид и обратно. Для простоты возьмем единичную точность, которая обычно в языках программирования представлена как тип *float32*, где

- первые 23 бита определяют мантиссу (<span style="color:#ffaead">fraction</span>)
- следующие 8 бит это порядок (<span style="color:#9fffad">exponent</span>)
- и последний бит - знак числа (<span style="color:#c5fcff">sign</span>)

![float32](./img/float32.png)

Используем формулы выше, но часть нам уже известна sign=0, так как число 0.15625 положительное, а bias=127 это константа для float32:

$$
(-1)^0 \cdot (1 + fraction) \cdot 2^{(exponent - 127)}
$$

Оценим число, чтобы найти остальные элементы. Тут все как с десятичной системой, нужно делить до тех пор пока не получим нормальную форму, когда результат станет от 1 до 2.

$$
0.15625 / 2^{-1} = 0.3125
$$

$$
0.15625 / 2^{-2} = 0.625
$$

$$
0.15625 / 2^{-3} = 1.25
$$

Получилось, что `(1 + fraction) = 1.25`, а `(exponent - 127) = -3`, тогда окончательный вид такой. 

$$
(-1)^0 \cdot (1 + 0.25) \cdot 2^{(124 - 127)}
$$

- 130 в бинарном представлении как раз `1111100`
- а 0.25 - `01000000000000000000000`

Представление 0.25 в бинарном виде в этом примере слишком очевидное, это 1/4. Другой вариант - это итерационное умножение на 2, когда берем целую часть, пока дробная не равна 0.

```python 
0.25 * 2 = 0.5 # берем 0, а дальше используем число 0.5 полностью
0.5  * 2 = 1.0 # берем 1, а дальше используем десятичную часть
0.0  * 2 = 0.0 # всё, больше уже ничего не измениться, дальше все 0
# ...
```

Но если взять другой, не такой "гладкий" пример, то есть вероятность, что получение мантиссы никогда не сойдется. Например, возьмем число `43.52`

$$
43.52 = (-1)^0 \cdot (1 + 0.36) \cdot 2^{(132 - 127)}
$$

```python
0.36 * 2 = 0.72 # 0
0.72 * 2 = 1.44 # 1
0.44 * 2 = 0.88 # 0
0.88 * 2 = 1.76 # 1
0.76 * 2 = 1.52 # 1
0.52 * 2 = 1.04 # 1
0.04 * 2 = 0.08 # 0
0.08 * 2 = 0.16 # 0
0.16 * 2 = 0.32 # 0
0.32 * 2 = 0.64 # 0
0.64 * 2 = 1.28 # 1
0.28 * 2 = 0.56 # 0
0.56 * 2 = 1.12 # 1
0.12 * 2 = 0.24 # 0
0.24 * 2 = 0.48 # 0
0.48 * 2 = 0.96 # 0
0.96 * 2 = 1.92 # 1
0.92 * 2 = 1.84 # 1
0.84 * 2 = 1.68 # 1
0.68 * 2 = 1.36 # 1
0.36 * 2 = 0.72 # 0 - упс, это уже где-то было
# начинали с такого числа 0.36
# нашли 21 из 23 нужных бит, но следующие 2 это повторения
0.72 * 2 = 1.44 # 1
0.44 * 2 = 0.88 # 0
# точно знаем, что последовательность периодическая и не сходится,
# но записать больше 23 бит физически не можем
# это похоже на бесконечные рациональные дроби вида
# 5/27 = 0.1851851851851851...
# только у нашей мантиссы 20 бит будут повторяться бесконечно
```

Получили запись `0 10000100 01011100001010001111011`,  это лишь приближение, а значит, что точного значения для числа `43.52` мы сохранить в памяти компьютера не можем, в каком-то вычислении ошибка все равно проявит себя:

```python
# python
>>> print('{:.15f}'.format(43.52))
43.520000000000003
```

Кстати, если заметили, то последний бит у мантиссы `01011100001010001111011` был не 0 как мы посчитали, а 1. Это из-за округления, примерно так же как если бы мы пытались записать десятичное число с точностью до 2-х знаков `round(0.005) = 0.01`.

## Конвертирование из машинного вида

Теперь возьмем любое число с плавающей точкой в бинарном виде и найдем его значение в десятичных дробях. Например `1 10000101 11101101110100101111001`:

- sign=-1, значит число отрицательное
- (exponent - 127) = 10000101 (bin) = 133 (dec), значит exponent=6
- `11101101110100101111001` раскладываем по степеням двойки

$$
1 \cdot 2^{-1} + 1 \cdot 2^{-2} + 1 \cdot 2^{-3} + 0 \cdot 2^{-4} + ... = 0.9290000200271606
$$

Получилось `-1.9290000200271606 * 2^6 = -123.45600128173828`. Кстати эту сумму я считал на компьютере, складывая float значения, поэтому тут уже есть дополнительная ошибка. Но начальное число для преобразования в бинарный формат я выбрал `-123.456`, ясно видим накопленные погрешности.

> А что не так с числом `16777217` из примеров в начале статьи? Почему ошибка такая большая, на 1 в целой части?

```go
// go
fmt.Printf("%f", float32(16777217.0)) // 16777216.000000
```

Проблема в том, что машинном виде по стандарту **IEEE 754** число будет представлено как `0 10010111 00000000000000000000000`, а это в точности такой же вид как и у числа `16777216`. У `16777217` мантисса полностью нулевая, а exponent=24, просто не хватило точности 23 бит для сохранения числа `0.0000000596046448`, единичный бит появляется только с 24-й позиции.

$$
16777217 = 1.0000000596046448 \cdot 2^{24}
$$

$$
16777216 = 1.0 \cdot 2^{24}
$$

## Способы работы с float в языках программирования

Это все были лишь теоретические выкладки, но есть способы посмотреть на приведение чисел с плавающей точкой к бинарному виду в явном виде.

В C/C++ можно посмотреть на код ассемблера и найти там нужную переменную как long.

```sh
gcc -S -O0 source_file.c -o-
```

В языке Go в пакет [math](https://pkg.go.dev/math#Float32bits) есть методы Float32bits/Float32frombits, которые позволяют делать конвертацию из float в uint и обратно.

```go
var (
	isFloat float32
	isUint uint32
)
isFloat = 43.52
isUint = math.Float32bits(isFloat)
// float=43.520000 -> binary=1000010001011100001010001111011
fmt.Printf("float=%f -> binary=%b\n", isFloat, isUint)

isFloat = math.Float32frombits(isUint)
// binary=1000010001011100001010001111011 -> float=43.520000
fmt.Printf("binary=%b -> float=%f\n", isUint, isFloat)
```

Для Python есть функция перевод массива байт (бинарного представления) во встроенный тип float [тут](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%BE%D0%B4%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8#Python).

## Как же хранить деньги

После всего вышесказанного возможно у вас возникли вопросы.

> Если у float такие ошибки, зачем его вообще использовать? И есть ли вообще способ считать точно?

1. Числа плавающей точкой можно смело использовать, но только не для финансовых расчетов, где важна каждая копейка. Существуют много разных областей, где такая ювелирная точность не нужна. Другой важный момент это скорость работы с ними. В современных компьютерах вычисления с числами с плавающей точкой поддерживаются аппаратным сопроцессором (FPU - floating point unit), а это существенное ускорение в работе, то на что когда-то и ставил Intel.
2. Да есть способ считать более точно, исключая погрешности до приемлемый границ. Далее рассмотрим тип Decimal.

## Типичные ошибки с деньгами

## Выводы

Главный вывод про стандарт **IEEE 754** и его систему хранения данных в том, что точность числа не зависит от количество десятичных знаков в человекочитаемом представлении, так как все равно происходить приведение к нормальной форме. То есть большие ошибки могут быть даже на очень коротких и простых числах. Или очень сложные на вид переменные хорошо попадают в степень двойки и хранятся без погрешностей.

Числа с плавающей запятой вполне могут использоваться для быстрых расчетов различных метрик, но только не финансовых.


## Ссылки


1. [754-2019 - IEEE Standard for Floating-Point Arithmetic](https://ieeexplore.ieee.org/document/8766229)
2. [The IEEE 754 Format](http://mathcenter.oxford.emory.edu/site/cs170/ieee754/)
3. Wikipedia [Single-precision floating-point format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format)
4. [Что нужно знать про арифметику с плавающей запятой](https://habr.com/ru/post/112953/)
5. Журал "Хакер" статья ["Всё, точка, приплыли! Учимся работать с числами с плавающей точкой и разрабатываем альтернативу с фиксированной точностью десятичной дроби"](https://xakep.ru/2015/01/01/vsyo-tochka-priplyli/). [Версия](https://habr.com/ru/company/xakep/blog/257897/) для Хабра.
6. Генри С. Уоррен ["Алгоритмические трюки для программистов"](http://www.williamspublishing.com/Books/978-5-8459-1838-3.html), 2-е издание (Henry Warren ["Hacker's Delight, 2nd Edition"](https://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685))
7. YouTube ["Как работают числа с плавающей точкой"](https://www.youtube.com/watch?v=U0U8Ddx4TgE)
8. [github.com/shopspring/decimal](https://github.com/shopspring/decimal)
9. [PEP 327 – Decimal Data Type](https://peps.python.org/pep-0327/)
